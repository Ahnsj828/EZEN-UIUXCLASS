1.js
  -map/set
  - interable 객체 / iterator / generator

2.Video Slide

3.Youtube 구현
  - 가로 슬라이드 기능
  - sticky 기능

4.Figma

5.HTML CSS JS 실용예제

JS 종말론
   - 전세계 프로그래머 설문조사 => 티오베? 에서 Python(백엔드 & AI) 1등
   - Python에서 Pyscript언어(JS와유사 / 웹브라우저 구현가능) 
   - 얘가 웹브라우저 영역까지 장악하려나?(HTML CSS JS)

React.js => Vitual Dom(가상돔으로 이루어져 있다) / html에 내용이 하나도없다
가상으로 돔을 만들고
거기에 값을 하나하나 넣고
이벤트를 만드는 

JS보다 React를 채용하는곳이 더 많다

모든 React는 JS를 기반으로 움직이는 언어다
JS기본 문법에 충실해라!!!

View를 많이 쓰기도한다
View역시 JS를 기반으로 움직이는 언어다
--------------------------------------------------------------------------------

MAP 객체 => 2015년에 ES6

arr.map()

나온 이유!
1) JS 객체 => 일반객체 , 배열객체(얘도 일반객체에 포합되어있지만 분리해서 분류한다)

2) 일반객체
장점 : key와 value 값을 가지고 있는 한쌍의 프로퍼티
  => 그만큼 데이터를 체계적으로 보관.관리.사용 가능하다
단점 : for...in => 객체 안에 있는 value값만을 찾아와서 직접적으로 반복문을 돌릴 수 있는 방법이 존재하지 않는다
단점2: 객체 안에 구성되어 있는 아이템들은 배열처럼 인덱스 번호를 할당받지 못한다

3) 배열객체
장점 : 배열안에 포함되어 있는 아이템들이 고유의 인덱스 값을 가지고 있으며, for문을 활용한 반복문으로 업무의 효율성 극대화
단점 : 객체처럼 key & value 형태로 구성된 체계적인 데이터 관리가 안된다(무엇을 지칭하는지 ..)

Solution : 일반객체와 배열객체의 장점만 모아서 하나로 만들어주면 어떨까? => Map 객체
(but, 실무에서 그렇게 많이 사용되지 않는다)

key, value값으로 구성된 아이템을 가질 수 있다
각 아이템별 인덱스 값을 할당 => for의 반복문을 활용해서 언제든지 값을 추출할 수 있다는 장점이 있다

배열과 같이 내부 아이템을 한개씩 찾아와서 반복 순회할 수 있도록 해주는 객체 => 이터레이터 객체
이터레이터 객체가 아닌 애들은 반복문을 쓸 수 없다

Map객체 => 데이터의 중복을 막을 수 없다!
동일한 데이터한 하나의 객체안에 들어오면 안되는 상황

일반객체 + 배열객체 + Map + 데이터 중복x => Set() set객체라고 부른다

--------------------------------------------------------------------------------

iterable object = 이터러블 객체
iterable : 순차적인 (사전적 의미), 순서대로 무언가를 처리할 수 있는(개념점 의미)
"순서"대로 무언가의 연산적업을 처리할 수 있는 객체
"순서" => index값처럼 순번 할당 값
일반객체 => 이터러블 객체라고 할 수없다 (순서가 할당되지 않아서)
자바스크립트에서 이터러블 객체 => 문자열, 배열, Map, Set

태생이 이터러블 객체가 아닌 요소들은 반복문을 사용할 수 있는 기회가 완전 박탈!!

태생이 이터러블 객체가 아니더라도 이 요소들을 이터러블한 속성으로 변경시켜서 반복문을 사용할 수 있도록 하기 위한 목적!!으로 지금 공부할거다

이터러블 객체 어떤 속성 & 특징을 알아볼거다



interabler Object 특징
1) for...of 반복문 사용 가능
2) ...전개연산자 구문 사용!
3) 구조 분해 할당이 가능하다
   (객체도 3번 가능하다 but, 1이랑 2는 사용못한다)


배열, 이터러블한 객체가 되기 위해서!!! 클래스 생성자 함수에는 심볼이 존재하는데, "Symbol.iterator" => 심볼 함수가 존재하기 때문에 배열은 이터러블한 객체가 될 수 있다!!

이터러블한 객체가 되기 위해서는 해당 객체에는 반드시 이터레이터 함수를 갖고 있어야 한다!!

유사 배열 => for /
유사배열은 next 함수를 갖고 있지 않을 수 있다 => 반복문을 쓸 수 없다

이터러블하지 않은 객체를 이터러블한 객체로 변환 시키기 위해서
=> 제너레이터 함수를 사용해야한다

객체를 생성하는것 자체 => 생성자함수 혹은 class를 활용해서 프로토타입 => 인스턴스화 하는 구조!

