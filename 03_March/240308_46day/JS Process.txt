<JS Process>

1.변수

2.자료형(태/식)


3.자료형 변환 = 형변환
- 문자 => 숫자 Number( )
- 숫자 => 문자 String( )
- 문자 & 숫자 => 논리 Boolean( )



4.연산자
- 산술연산자 
- 연결연산자
- 할당연산자
- 비교연산자
- 논리연산자
(*삼항 조건연산자)



5.제어문
- 조건문
> if문
> if...else문 (*else if)
> switch...case문

- 반복문
> for문
> forEach문
> for...in문
> for...of문
> while문
> do...while문
(*break문 & continue문)



6.함수
- 클래스 / 익명 / 화살표
- 매개변수 & 인수(*인자값)
- return (*함수 결과값 반환)
- 스코프 (*블록 / 지역 / 전역)
- var x / 지역스코프 변수 / const (*권장)
- 즉시실행함수
- 변수선언 키워드 입력 => 전역변수
- hoisting (*클래스함수 VS 익명함수 & 화살표)
- 1급 시민
- 전개연산자 구문
- 나머지 매개변수
- 시간관련 내장함수
(*setInterval / clearInterval / setTimeout)
- 재귀함수



7.DOM
- querySelector / getElement
- innerText / innerHTML / textContent
- "on" 이벤트 핸들러
- classList
- add( ) <-> remove( ) / toggle( )
- contains( )
- form
- dom 선택자를 통해서 값을 찾아오는 방법 => value
> #, ., tag
> name
> form 배열 요소



8.Event
- 이벤트 종류
> 문서 로딩 이벤트
> 마우스 이벤트
> 키보드 이벤트
> 폼 이벤트
- 이벤트 처리
> 인라인 스크립트 : html 문서에 직접 이벤트 정의!!!
> 외부 스크립트 : 이벤트 핸들러
> 외부 스크립트 : 이벤트 리스너
- 이벤트 전파
> 이벤트 버블링
> 이벤트 캡처링



9.DOM 심화
- createElement( )
- createTextNode( )
- appendChild( )
- createAttribute( )
- setAttributeNode( )
- remove( )
- parentNode
- removeChild( )



10.객체
- window : 웹 브라우저 안에 있는 최상위 "객체"
> 내장객체 : window 기본적으로 탑재되어있는 객체
- Date( ) (날짜객체)
- 밀리초
- Math (수학객체)



11.객체 심화
- 객체 key & value : Property 
- 객체 Property 삭제 : delete object.key
- 객체 중첩
- 객체 메서드 함수
- 객체생성 방법
> new Object( )
> 생성자함수
> class
- 객체속성 반복
> Object.keys( )
> Object.values( )
> Object.entries( )
- 생성자함수 & class 상속
> prototype 속성
> __proto__ 속성
> 생성자함수 : Object.setPrototypeOf(상속받고자 하는 함수, 상속가능한 함수)
> class : extends 키워드를 활용해서 상속



12.문자열
- charAt( ) : 매개변수의 인덱스값을 가지고 있는 문자열을 찾아올 때
(*문자열[인덱스값]으로도 사용가능!)

- indexOf( ) : 매개변수 문자열을 처음 찾았을 때의 인덱스 값을 찾아올 때

- startWith( ) : 문자열 전체에서 처음 시작하는 단어가 맞는지 확인
(*매개변수 2개를 전달 : 첫번째 매개변수가 두번째 매개변수의 위치에서 시작)

- endWith( ) : startWith( ) 문법과 동일하게 작동 (*문자열의 뒤에서부터 서칭)

- includes( ) : 문자열 안에 매개변수의 문자가 있으면 true / 아니면 false

- trim( ) / trimStart( ) / trimEnd( ) : 문자열의 전체/앞/뒤에서 빈문자열을 찾아서 없애주는 기능

- substring( ) : 매개변수는 1개 혹은 2개 입력가능!!
> 매개변수 1개 : 해당 매개변수의 인덱스값부터 문자열의 끝까지 모두 찾아오는 기능
> 매개변수 2개 : 첫번째 매개변수 부터 두번째 매개변수의 바로 앞까지 문자열을 찾아오는 기능

- slice( ) : 기본적으로 substring( )과 문법이 동일하나 차이점 => 음수 매개변수를 인식한다!!!

- split( ) : 매개변수를 기준으로 값을 나눠서 배열로 변환시키는 함수



13.정규표현식
- 패턴/플래그
- ^:캐럿 (*특정 문자열로 시작할 때 사용)
- $:달러 (*특정 문자열로 끝날 때 사용)
- []: 범위설정 (*^의 경우, 범위 영역 내.외부에 따라 의미 상이함)
- [0-9] : 모든 숫자 의미
- [a-z] : 모든 문자 의미
- /[a-z]/i : 플래그 i => 대.소문자 구분없이 모두
- /[a-z]/g : 플래그 g => 문자열 내 해당되는 모든 문자 선택
- /\d{3}/ : 숫자 3개 나열되는 문자열 선택
- test( ) : 정규표현식에 일치하는 부분 문자열이 있으면 true, 아니면 false
- match( ) : 정규표현식에 일치하는 부분 문자열 찾기



14.문자열 및 배열 메서드
- split( ) : 구분자를 기준으로 문자열을 배열로 변환
- [...str] : 순수 문자열을 배열로 변환
- Array.from(str) : 순수 문자열을 배열로 변환
- arr.join(구분자) : 배열을 다시 문자열로 변환
- 배열생성하기 : new Array( )
- forEach(값, 인덱스, 배열)
- 서로 다른 배열 합치기
> arr.concat(배열, 배열)
> [arr01, ...arr02]
- reverse( ) : 배열 요소를 거꾸로 나열할 때 사용
- sort( ) : 배열 내 값의 크기에 따라 내림차순 및 오름차순 정렬
- pop( ), push( ) : 배열 내 맨 뒤에 값을 제거 및 추가할 때 사용
- shift( ), unshift( ) : 배열 내 맨 앞에 값을 제거 및 추가할 때 사용
- arr.splice(위치) : 특정 위치 부터 끝까지 요소 삭제
- arr.splice(위치, 숫자) : 특정 위치 부터 숫자 개수만큼 삭제
- arr.slice(위치) : 특정 위치에서 끝까지 추출
- arr.slice(위치01, 위치02) : 위치01에서 위치02직전까지 추출
- splice( ) VS slice( ) 차이점 : splice는 원래배열에 영향을 줌 / slice는 원래배열에 영향 안줌
- map( ) : 기존 배열을 둔 상태에서 새로운 배열을 만들고 싶을 때
- filter( ) : 기존 배열에서 특정 조건에 부합하는 요소만 추려서 새로운 배열을 만들고 싶을 때
- reduce( ) : 기존 배열 내 아이템을 하나씩 찾아서 누적 연산작업을 하고 싶을 때



15.복습 & ES6문법
 - 객체 & 배열 복습
 - ES6 업그레이드된 문법

  1) 함수
    > 매개변수 기본값 설정
    > 나머지 매개변수 사용하는 방법

  2) 배열
    > 서로다른 배열을 하나로 합치는 방법 : [...arr, ...arr]
    > 배열을 복제하는 방법 : [...arr] => 원.사본 배열의 연관관계 X

  3) 객체
    > value를 찾아오는 방법 2 : 온점표기법 / 대괄호표기법(*문자열 형태로 값을 찾아온다)
    > 객체 key 생성 시, 외부 함수를 활용

  4) 심볼
    - 심볼 값을 찾아 올 때에는 반드시 [ ](*대괄호) 표시로 찾아와야 한다!
    - 심볼 전역요소로 생성 / 찾아올 수 있음
    - 심볼 값을 복제해올 수 있는 방법 : Symbol.for()
    - 심볼 값에 매칭되어지는 값을 찾아오는 방법 : Symbol.keyFor(심볼값)

  5) 구조분해할당
    - 배열 및 객체 가능!
    - 구조 분해 할당하고자 하는 자료형의 타입을 값을 받는 요소에서도 동일하게 사용!
    - 객체의 경우, 반드시 변수명 === 객체의 key 이름과 동일!!
    - 배열의 경우, 전개연산자를 활용해서 구조분해할당 가능!!
    - 중첩객체에서 구조분해할당 하는 방법 => 가능!!


16. Map / Set  (14에 map과 다르다)
    - 기존 일반 객체 & 배열객체의 장점을 모아서 만들어진 Map객체
    - Map객체 특징 
       > key, value 구성
       > 각각의 key에는 index 존재
       > key, value 추가 => set( )
       > Map객체에서 특정 값을 가져올 때 => get( )
       > Map객체에서 특정 값이 존재하는지 확인 => has( )
       > Map객체의 모든 데이터를 삭제 => clear( )

    - 중복된 데이터를 허용하지 않는 Set 객체
       > Map객체와 동일하게 프로토타입을 통해서 인스턴스 객체화!!
       > Map객체와 달리 value값만 존재
       > Set객체의 값을 추가 => add( )
       > Set객체에서 특정 값을 가져올 때 => get( )
       > Set객체에서 특정 값이 존재하는지 확인 => has( )
       > Set객체의 모든 데이터를 삭제 => clear( )


17. 서버와 통신
    - Server
    - http & https : 통신규약
    - Server & Client 통신 언어 : JSON
    - JSON : Javascript Object Notation
    - AJAX : Asynchronous Javascript And XML
       (*비동기 처리 방식으로 클라이언트와 서버가 통신 기법 중 하나)
    - AJAX 통신 기법을 활용한 통신 방법이 여러개가 있다 / 시대에 따라서 발전해왔다
       > XMLHttpRequest 과거에 사용하던 방식
       > fetch( ) 일기예보 데이터 / 영화 정보 데이터 => 현재 가장 트랜디한 방식


==========================================================


서버 & 통신
1. 왜 필요한가? 이유 설득 & 합리적  => 이게 필요하면 더 잘 습득한다
html, css, js => 기초 문법 / 예제
--------------------------------------------------------
ToDoList => js의 백미 / js문법이 집약적으로 들어가 있다
1) 기본 레이아웃 정렬 문법이 들어가있다
2) DOM활용해서 사용자 데이터 값을 수신하는 장치가 들어가 있다
3) 의도한 화면 영역에 출력해줘야하는 이벤트가 들어가 있다
4) 사용자에게 수신받은 데이터를 저장시키는 기능이 탑재가 되어있다
  => 그래서 신입들이 포폴에 ToDoList가 들어가 있다 / 단 자신만의 커스터마이징으로
  => 그래서 ToDoList 이해도가 있어야한다
----------------------------------------------------------
만약, 용량 큰 데이터를 사용자에게 받아서 처리해야하는 상황이라면?

팀플 다들 html,css에 하나하나 다 적고 있다
어딘가에 문안 & 이미지 & 동영상 호스팅 => 가져다가 사용 가능할까? => 서버 & 통신 이거로 가능할까
------------------------------------------------------------
서버 : 사용자가 입력한 데이터를 보관.처리하는 웹 상의 가상 공간

프론트엔드개발자 : 사용자의 데이터를 수잡하고 / UI 레이아웃 설계 구현

풀스택 개발자 of 백엔드개발자 : 서버 구현(서버 구축한다고 부른다) + 데이터 비관계형 & 관계형 데이터 베이스 설계 => 데이터를 사용할 수 있도록 만드는 작업을 한다


input => id & pw 
약속!!을 지켜야지만 서버에게 데이터를 보낼 수도 있고, 가져올 수도 있다
  => 이걸 서버 통신 이라고한다
     서버통신은 규약이 존재!! => 프로토콜 : 약속, 규약 => http 
http = hyper text tranfer protocol
h1태그를 쓰면 heading의 가장큰 사이즈 텍스트를 갖게하자는 등등의 약속
https:www.naver.com 주소는 네이버에 접속할수 있다
 앞에 https를 붙여서 접속할수 있다 => 규약.약속을 지켰기 때문에 서버에 접속 할 수 있는거다 

http로 되어있는 주소의 사이트에 가면 => 신뢰할 수 없는 웹 사이트 돌아가세요! 라고 문구가 뜬다
아니면 차단되어 있어서 못들어가기도 한다
s가 안붙어 있어서 그런거다 / s는 기본이다(s는 보안패치) / 무료사이트도 보안패치를 붙여야 배포가된다

s : security : 보안
보안 영역 => 억대연봉 / AI가 발달할 수록 각광받는다
--------------------------------------------------------------------
서버와 통신규약을 지켰다!
서버 목적 => 데이터를 가져오던가 or 데이터를 전달하던가(로그인 / 사용자 id,pw 입력해서 정보를 전달)

method : get => 서버에 특정 데이터를 요청하겠다는 의미!
method : post => 서버에 특정 데이터를 보내겠다 (주겠다는) 의미!
-----------------------------------------------------------------
firebase Deploy 파이어베이스에 배포할때 안될때는 404가 항상 나왔다
200 : 서버에 정상적으로 자료를 요청했고, 서버 역시 정상적으로 자료를 전송해주었다는 의미
404 : 서버에 어떤 데이터를 요청했는데, 그 데이터를 찾지 못할 때 서버가 알려주는 번호!
  400 || 401 || 403 
  => 401 : 정상적으로 요청하였으나, 권한이 없는 (특정 url통해서 오거나 특정 pw입력해야만 들어갈 수 있는..)
  => 403 : 권한요청이 없음에도 지속적으로 이 페이지에 접속하고자 할 때
503 : 정상적으로 서버에 데이터를 요청했으나, 서버가 정상적으로 작동할 수 없음을 알려주는 번호! => 서버가 다운되었다!! 
      (동시간대에 여러 사람이 접속했을때 / 수강신청할때 / 콘서트 예매할때 등등 / 접속 폭주)
      코로나 터졌을때 마스크 대란일때 네이버마켓에서 최저가로 판매할때
---------------------------------------------------------------
JSON : Javascript Object Notation 의 약자
자바스크립트 객체 표기법

const obj = {
  title: "title",
  price: 15000,
}
자바스크립트에서 무언가를 표기하는방법

만약!! JS 언어를 그대로 가지고, 서버 구현하고 데이터 베이스를 구축할 수 있다면
  1) 프론트엔드 개발 VS 백엔드 개발  => 연봉차이가 날 이유가 없다
  2) 태초에 JS 언어는 => 웹브라우저에서만 사용할 수 있도록 만든 한정적인 제약언어이다!
  3) 서버 구현 & 저장 데이터 관리할 수 있도록 해주는 언어 => Java & C++ or C# oc C
     언어 전통적으로 서버에서 사용할 수 있는 언어들!!
  4) 웹엔앱 ui 영역이 각광을 받은지 얼마 안됐다 /  서버를 중심으로 언어가 측정되었다
  5) 서버 측 언어에서 => JS언어

 node가 js로 서버를 구현할 수 있게 했다
 js 언어의 인기는 계속 올라갈거다

<test.js>
{
  "name": "홍길동",
  "major": "음악과",
  "grade": 3
}

js -키값에 절대 ""가 들어가지 않는다
json - 키값에 ""가 꼭 들어간다

서버와 "우리"가 통신한다 = 서버와 클라이언트가 통신규약 아래에서 통신을 한다!!



AJAX : 클라이언트(우리) & 서버간 통신을 할 수 있도록 해주는 통신 기법
Asynchronous Javascript And XML
Asynchronous : 비동기
Javascript : 웹 사용가능 자바스크립트 언어
JSON : 언어를 의미하는 것이 아니라, 자바스크립트 언어를 서버가 이해할 수 있도록 변환시켜주는 표기법 / 서버에서 가져온 데이터를 웹브라우저가 이해할 수 있도록 변환시켜주는 표기법
JSON은 표기법이지 언어는 아니다
XML : 과거 서버에서 실질적으로 사용할 수 있는 언어

동시다발적으로 불러와라
동기방식 => 하나 부르고 다음 하나 부르고...
앞에 요소가 데이터 용량이 크면 오래걸리는데 비동기는 먼저 준비된 애들부터 데려오는거다
---------------------------------------------------------------
XMLHttpRequest 과거에 사용하던 방식 / 서버와 비동기처리 방식으로

JS DOM => Event
export. 버튼 / 오버
1) 이벤트 핸들러
  button.onclick = function() {}
    // 앞에 on붙었다 => 무언가 기능과의 매개체 역할을 하는 핸들러다!
2) addEventListner()

onreadystatechange : 클라이언트가 서버에 데이터를 요청하고, 서버에서 데이터를 전송해주는 과정속에서 데이터가 이동될 때마다 실행되는 이벤트 핸들러!
readyState: 값
readyState: 0 => 클라이언트가 서버에 아무런 요청을 하지 않은 단계
            1 => 클라이언트가 서버에 자료를 요청하고 성공한 상태
            2 => 클라이언트가 서버에 자료를 요청한 이후 서버가 클라이언트 측에 응답메세지를 헤더로 전송한 상태
            3 => 서버에서 클라이언트 측으로 데이터가 전송중인 상태
            4 => 서버가 정상적으로 클라이언트측에 데이터를 전송완료했고, 이제 클라이언트 측에서  데이터를 마음껏 사용할 수 있는 상태
---------------------------------------------------------------
JSON에서 => 여러개 종류의 데이터를 종합적 관리하는 JSON만들고 싶다 => 배열의 형식을 띄어야한다
         => 여러개 데이터를 관리할때는 배열로 해줘야한다


동기처리 방식도있나?
ex. 내피부타입 설문조사 하고 그 데이터를 서버에 보내고 그후에 화장품 추천을 받아야한다
     그런경우는 동기처리로 받아야한다


try {
  // 정상적으로 데이터를 받게되성ㅆ을때
  console.log("시작");
  add();
  console.log("실행 중...");
  // 실행시킬 요소문
} catch (err) {
  // 에러가 발생된 순간 try문에서 참조변수값?으로 catch한테 전달
  console.log(`오류발생 : ${err}`);
  console.log(`오류발생 : ${err.name}`);
  console.log(`오류발생 : ${err.message}`);
} finally {
  console.log("끝");
}


------------------------------------
마우스 & 손가락
click : 마우스를 클릭했다가 떼는 순간 이벤트 발생!
마우스를 눌려져있는 상태에서 / 누르고 있는 상태에서 이벤트가 발생된다 => mousedown
손가락 이벤트 => touchstart

컴퓨터 혹은 모바일 디바이스는 사용자가 얼만큼 스크롤을 했는지 어떻게 알 수 있을까?

사용자가 스크롤하고 두번째 스크롤할때 컴퓨터가 어떻게 알 수 있을까?

scrollWidth : 사용자가 스크롤을 할 수 있는 전체 총 너비값 (디바이스 너비값이 아니다! )
               디바이스에 나타나지 않더라도 내가 스크롤할 요소의 너비값
clientWidth : 사용자의 눈으로 확인이 가능한 디바이스 매체상의 너비값 (디바이스의 너비값)