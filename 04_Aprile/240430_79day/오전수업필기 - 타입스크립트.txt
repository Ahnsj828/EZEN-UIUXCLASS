< 세팅 순서 >
1. Node 초기화 명령어 (*질문 생략)
npm init -y  npm초기화
  
   전날꺼 복붙하려면
   전날 작업한 폴더에서 
     package.json package-lock.json tsconfig.json  복붙하면된다

2. Node 내장 함수 및 명령의 타입 정의
npm i @typs/node

3. 타입스크립트 컴파일링 세팅 명령어
npm i ts 컴파일링 해주는 명령어
npm i tsc -g 전역요소에 컴파일링 해주는 명령어

4. 타입스크립트 컴파일링 & 실행 세팅 명령어 
npm i ts-node 
npm i ts-node -g

5. 모듈 설정 후 컴파일링 & 실행 세팅 명령어 
npm i tsx
npm i tsx -g

6. 타입스크립트 컴파일러 옵션 세팅
tsc -init 컴파일링 옵션에 대한 초기화

---------------------------------------------------
<컴파일 옵션>
tsconfig.json에서 =>
 {
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    // 서로다른 변수로 인식시키기 위해
    "esModuleInterop": true,
    // CJS를 ESC로 가져오기 위해
    "moduleResolution": "Node",
    "sourceMap": true,
    "downlevelIteration": true,
    // 반복문 쓸때 에러생기는거
    "noImplicitAny": true,
    "allowJs": true,
    "skipLibCheck": true,
    "noImplicitThis": false
  },
  "ts-node": {
    "esm": true
  },
  "include": ["src"]
}

package.json에서 =>
"type": "module",

===============================

새폴더 만들기
package-lock.json  package.json   tsconfig.json  복붙
package-lock.json  package.json에 "name": "1_ts", 맞추기
터미널 열기
cmd 열기
npm i 입력

src폴더 만들기
파일 만들기

===============================

터미널에
tsx src/file.ts
tsx src/파일명.ts
컴파일링 명령어

=======================================

TS에서 class를 생성하거나 상속하거나 받는 개념 거의 동일하나, 살짝 "접근제어자 + 타입정의"만 상이함!
거의 똑같다 근데 "접근제어자 문법 + 타입정의"가 들어간다

< TS 접근제어자 >
public 접근제어자 : 모든 범위에서 접근할 수 있는 제어자 설정
=> class를 생성 기본 세팅된 default 제어자
private 접근제어자 : class 내부 범위에서만 접근할 수 있는 제어자 설정
 => 실무에서 대부분 이걸로 만든다
protected 접근제어자 : class 내부 + 상속받은 파생 클래스에서만 접근할 수 있는 제어자 설정


< 추상클래스 >
추상 : 여러개의 사물이나 개념의 공통적인 요소를 추출해서 만들어내는 개념이다
사용목적 => 공통적인 속성을 가지고 있는 서로 다른 요소의 객체를 만들어야하는 경우!
단, 추상클래스가 되려면 반드시 공통적인 속성 및 매서드가 1개이상 존재해야한다
= 추상컨셉의 속성 및 매서드가 1개 이상 있어야한다

추상클래스도 클래스다
추상클래스도 일반적인 다른 클래스처럼 인스턴스를 만들어낼 수 있을까?
추상클래스도 클래스인것은 맞으나, 일반적인 클래스처럼 인스턴스를 만들어낼 수 는 없다

클래스를 선언할 때, 클래스안에는 속성을 설정하기도 하고 & 매서드를 설정하기도 한다
클래스 만드는 이유 => 객체생성

class를 객체를 생성하기 위한 하나의 프로토타입
그렇다면, class도 곧 객체 아닌가?
class 내부에 존재하는 속성, 메서드를 활용해서 바깥에서 직접적으로 사용?
원칙적으로는 class 내부에 존재하는 속성, 메서드를 바깥에서 사용하려면 
인스턴스 객체를 생성한 이후에 해당 인스턴스의 속성 값을 활용해서 
사용하는 것이 문법적으로 맞다
static : 정적인 <=> interactive : 동적인



< 함수 >
왜 사용하고 어떻게 사용하는가?
어떤 값을 받은(*매개체) 후 어떤 연산 및 기능작업을 거쳐서 어떤 값을 반환(*제공)하려고 사용하는거다
타입스크립트 : 어떤 값들의 타입을 정의한다
매개변수 타입 정리 => 매개변수도 변수다
반환값 에대한 타입 정리

< 기본적인 함수형태 >
function add() {

}

< 익명 함수 형태 >
const add1 = function() {

}

< 화살표 함수형태 > => ES6이후 JS 문법이라서 수업시간에 많이 사용했다
이벤트 리스너에서는 화살표함수를 사용했을 때, this객체가 가리키는 것이 이벤트 대상이 아니라 window function
const add2 = () => {
	
}



반환값이 없는 함수는 결과 값으로 어떤 타입(eturn문을 사용하지 않는 함수)을 정의해야할까?
=> void : 반환값을 갖지 않고 있는 함수의 최종 타입을 정의하고자 할 때
void : 피하다 회피하다

타입 별칭 => 함수 타입 시그니처 대체 하기 위한 목적이다

