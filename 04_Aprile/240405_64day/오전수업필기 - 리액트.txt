1. 기본 개념
- components
- virtural Dom
- CSR

2. JSX 문법

3. props 객체

4. state 변수: component가 가지고 있는 상태값
 - 상태 값을 변경하려면 useState() : React Hooks중 하나!!
 - form 태그 요소 안에 있는 기본적인 input 태그 || textarea || select && option
 - 상태의 변화값을 check하고 state 변수값이 업데이트가 될 수 있도록 제어!!

5. props & state 변수 동시에 활용!!

* React Hooks
 -> 언제 , 어떤 리액트 훅을 가져다가 사용해야하는지 모르겠다는 질문

*JS
 짝수 ===> %2 ===0

** 왜? 컴포넌트를 자꾸 만들어서 작업하는가?
 1) React 장점 : JS를 활용 작업 => 300줄 / 문제 = bug
 300줄 달하는 JS 문장 하나씩 검증 해야한다 => debuging

 2) conponent 안에 존재하는 state 변수값이 업데이트가 되는 순간 => rerendering 리랜더링

 * React는 Rendering이 매우 중요한 개념!!
 => html을 포함한 기타 웹브라우저 parsing할 수 있는 문서를 웹 브라우저가 화면에 출력해주는 기능
     =>이 기능을 rendering이라고 한다

  랜더링이 언제 발생하는가?
   0) component가 mount(탄생되는순간)가 되는 순간 무조건 최초 rendering이 발생
   1) component의 state값이 변경되면 무조건 rendering이 발생
   2) 부모 component로 부터 받아오는 props의 값이 변경되면 무조건 rendering이 발생
   3) 부모 component가 rendering이 되면, 무조건 자식 component도 rendering이 된다

* 리액트 훅 : useRef( ) : 특정 돔으로 활용할때 사용
 - Ref = reference 약어 => 참조 라는 뜻
 - 기존 JS, DOM을 활용해서 html 문서를 컨트롤했던 그 기능!
 - JS에서 DOM을 활용해서 input.valuse = ""
  
useState( ) : Component의 State 변수값을 컨트롤 해주는 훅 함수
useRef( ) : 특정 요소의 DOM을 컨트롤 해주는 훅 함수
useEffect( ) : 컴포넌트의 "생애주기(= life cycle)" 를 컨트롤 해주는 훅 함수
   => 중요하다!!

 - 사람도 생애주기가 있다 
 - 탄생 -> 유아기 -> 청소년기 -> 성인 -> 노인 -> 사망
 - 컴포넌트도 생애주기가 존재한다
 - mount(컴포넌트가 시작됐다/ 탄생됐다) -> update(컴포넌트가) -> unmount(컴포넌트 기능종료)
 - 리액트는 가상돔 사용하고 훅으로
       date컴포넌트가 업데이트가 될때 이걸해줘
 1) 의존성 배열이 업데이트 or 변경되면 useEffect( ) 안에 callback 실행
    API데이터 끌어올때 사용한다
    => 외부 API => state
    => 웹 브라우저 처음 켜졌을 때에는 data x
    => 사용자가 지역 매장정보 값 보려고 버튼을 누르거나 select
    => 의존성 배열에 복수의 state값을 적용한 경우, 그 중 1개만 업데이트가 되어도 useEffect( )실행

 2) 만약, "의존성 배열"을 설정하지 않은 경우, 컴포넌트가 랜더링 될 때마다 콜백함수를 실행시킨다
 
 3) 만약, "의존성 배열"에 빈배열을 적용하는 경우, 컴포넌트가 최초 mount가 되는 시점에만 딱 한번 실행

 => API 데이터를 가져와서 사용해야하는 그 시점!!
 => 웹브라우저를 처음 켜자마자 바로 무언가를 딱 한번 실행시켜야하는 상황!!
     ex. 팝업창 
업데이트 해야될때 => 연산작업해야할때 사용

cleanup 개념 



*ToDoList => React.js
* 어떤 기능을 구현할것인지에 대한 정의 => 화면 UI 설계  => 기능 부여
 > Header 컴포넌트 : ToDoList 소개 & 설명하는 텍스트 역할
 
 > ToDo Editor 컴포넌트 :
     - Input태그영역 / 사용자가 지금 해야할 일을 입력하는 영역

 > Todo List 컴포넌트 
     - 사용자가 editor를 통해서 입력한 state 값을 받아서 출력 영역

 > Todo Item 컴포넌트
     - 사용자가 Todo List를 통해서 입력한 값이 

 <TodoList 앱의 component 구조>
                 _____   App _________
                 |          |              |   
           Header   TodoEditor  TodoList
                                             |
                                       TodoItem
------------------------------------------------------------------
* node Modules 삭제하고 다시 작업을 하고싶다!! => npm i
삭제했는데도 되는 이유?
  => package.json에 "dependencies" 때문에 가능한거다 
      "dependencies"는 알고있어서
npm i는 "dependencies" 를 다시 설치해주겟다라는거다
package-lock.json에는 상세하게 나와있다
구체적인 버젼 등등이 나와있다
어제버젼과 달라졌는지 등등을 확인 할 수 있다

실무에서 어제까지 작업했던게 하루사이에 업그레이드가 되서
이전버전과 호환이 안될때는 안열린다
------------------------------------------------------------------

Data를 어떻게 저장하고 관리할 것인가?
 1) 어떤 데이터를 수집할 것인가?
   - id -> 아이템(할일목록들)마다 고유의 id가 존재해야한다
   - boolean -> 할일을했는지 안했는지 여부
   - todotext 
   - tododate

 2) Mockup Data를 임시로 생성해 놓고 작업
   - 샘플링 된 작업물

 3) Mockup Data는 어떤 컴포넌트에 존재해야하나? => App 

 4) 우리는 어떤 방식으로 위에서 수집한 Data를 보관?
   보관 => 변수명을 선언하고 변수값을 할당 : 변수를 생성!!

 윈시타입 / 참조타입
   - 객체유형 타입 자료 1차 저장을 해야한다!!
   - filter함수 => 이터러블 객체
   - 순회가능 데이터 형태
   - 배열
     데이터를 하나씩 추가하고 데이터를 검색하려고한다 =>검색기능 => filter => 배열

React.js 와 같은 프론트엔드 라이브러리 혹은 프레임워크를 사용해서 Data를 관리하게되면 
항상 다음과 같은 프로세스 과정을 기억하고 실행할 준비를 해야한다!!!

* CRUD 프로세스 (웹페이지에 항상 존재한다)
   - create : 컨텐츠 생성
   - Read : 생성된 컨텐츠 확인. 읽을수 있는 기능이 있어야한다
   - Update : 최초 생성한 데이터를 업데이트기능
   - Delete : 과거에 생성했던 데이터를 삭제할 수 있는 기능
       ===>> CRUD 순서에 맞춰서 기능을 만들어야한다



1. 부모 컴포넌트 내부에서 자식 컴포넌트를 만들어서 해당 컴포넌트를 
   또다른 자식 컴포넌트에게 전달!

2. 자식 컴포넌트에 key와 value값을 생성해서 전달하는 방법

* 삭제하기 버튼이 눌려진 아이템을 제외한 나머지 아이템들만 따로 다시 모아서 재출력!!

=========================================================

npm i   or  npm instal
npm run start

< 리액트 훅 >
  * useState
  * useRef
  * useEffect
  * useReducer (고차함수라한다)

* 상태관리 / 상태 = state
  - useState( )
  - component 상에 변화 및 업데이트가 필요한 요소가 존재 => 이 존재를 관리
  - 하나의 컴포넌트 안에 관리해야할 상태가 많아지면 어떤 문제?
  - 컴포넌트 state 업데이트가 되면, 컴포넌트는 리랜더링이 된다
     랜더링 = 웹브라우저가 컴포넌트를 다시 불러오는거
  - 리액트를 사용하는 이유?
     > 컴포넌트기반 , 가상돔 사용 => CSR 방식 사용 => 서버의존도 높은 SSR보다 UI 화면 출력 매우 빠르고, 효율적이다!
     컴포넌트가 비대해질수록 리액트 사용하는 이유가 없어진다

  상태관리의 효율성 
    => useReducer (얘도 리액트 훅이다)
    => reducer JS함수 : 누산기  
    => 무언가를 차곡차곡 쌓아서 어떤 작업을 실행하는 개념

  useState( ) : 컴포넌트 바깥에서 실행해본 적 없다!
   => 바깥에서 실행이 되긴하는데 딱 1번만 실행이되고, 이 실행을 무한반복한다
   => setCount 함수 컴포넌트 바깥으로 나가게 되면
   컴포넌트가 리랜더링 되는 순간 count의 값을 최초의 초기값으로 reset시킨다

   useState함수를 밖에쓰게되면 
  오늘 예제 테스트 컴포넌트의 +버튼 누르면 1만된다 2,3,4,5..는 안된다

* <=이거를 우리는 전체선택자 라고하지만  / 정식명칭은 wildcard selector 라고한다
wildcard  비장의 무기



React.js 최적화 3가지 방법
 1) 리액트 훅 : useMemo
    - 메모이제이션 : 메모장을 써서 이건 이거라라고 언급.정의 해주는거
                         불필요하게 안돌게끔
    > *메모이제이션을 하고자 하는 함수를 콜백함수로 사용,
       두번째 매개변수로 의존성 배열
    - 불필요한 함수 재호출 방지를 하고자 할 때

 2) React.memo(리렌더링을 방지하고자 하는 컴포넌트)
    - 불필요한 컴포넌트를 리렌더링을 방지하고자 할 때
     오늘 파일에서 불필요하게 리렌더링 할 필요없는애  => Header

  *컴포넌트가 렌더링 되는 3대 포인트
  - state 상태 값이 변화
  - props 값 변화
  - 부모 컴포넌트 렌더링 일어나면 => 자식 컴포넌트한테도 렌더링이 일어난다

  * JS 초기 학습
   - 원시타입 자료
     (* 문자열, 숫자, 불리언)
   - 참조타입 자료
      (* 객체 기반의 자료 => 객체, 배열, 함수)
      (* 함수 => 
           함수기원 -> class객체의 constructure => 프로토타입 객체 => 인스턴스 객체)
      (* 부모 프로토타입 설정, 객체 키 & 메서드)
       그래서 함수를 객체 기반 자료라고 부르는거다
     변수 안에 원본 객체가 존재하는데
      만약 원본객체를 2번째 변수로 복사를 하고 
       복사된 변수를 수정하게되면 독립적인 요소로 움직이게된다

 3) React.memo( ) / useCallback( )
   useCallback(콜백함수, 의존성배열)
       의존성배열이 변화가 감지가 되면 콜백함수가 작동된다
   useEffect(콜백함수, 의존성배열)



* 최적화!!!
1)작업중인 모든 컴포넌트와 함수를 다 최적화!! => 불가 / 쓸데없는 짓이다!!
(*반드시 꼭 필요하다고 생각하는 요소만 최적화하기!)

2) 최적화는 반드시 컴포넌트의 작업이 어느정도 완료가 되는 시점에서만 해야함!!
  - 기능구혐 > 최적화
  - 최적화 > 기능구현
    기능구현이 먼저다!!!
  -  어느정도 완료가 되는 시점에서 해야하는 이유 :  기능구현이 풀려버린다

3) 최적화는 정답이 없다!!
  - 최적화 방법 3대장
  


* 데이터 효율성
props Drilling 문제 (qpp에서 TodoItem로 가려면 TodoListㄹ를 거쳐서 가야한다)

Context : 책 => 목차 => 맥락
Context를 활용하면 한번에 연결 가능하다
                 _____   App _________
                 |                         |   
           Header      ______  TodoContext => 데이터 보관소______ 
                          |             |      |     |                            | 
                          |    TodoEditor  |    TodoList                   | 
                          |                    |                                  |  
                          |               TodoItem                            |  
                          ------------------------------------------------- 

Context를 활용한 API => Canvas API / Localstorage

데이터를 공급하는 root 컴포넌트에서는 
React.createContext() 활용해서 객체 컴포넌트를 생성
생성된 객체 컴포넌트에서 .Provider라는 속성을 사용해야지만 
데이터를 공급할 수 있는 환경설정이 가능하다
이때, root 컴포넌트에서 공급받은 데이터 중 자식 및 손자 컴포넌트에서 전달 하고자 하는 
데이터는 value라는 key를 활용해서 정의하면 된다!!

이제, 데이터를 공급받아야하는 컴포넌트에서 준비해야한다!!
react 라이브러리에서 useContext 훅을 찾아와서 
해당 훅 함수의 반환값을 특정 변수안에 할당!!
(* 이때, 해당 훅 함수의 매개변수는 부모요소에서 정의했던 Context API 컴포넌트로 적용!!)

리팩토링!!
 => JS 함수기능 => 요소
 => 1개의 함수안에 너무 많은 기능 포함
 => 버그 발생 리스크

                 _____   App _________
                 |            |              |   
           Header          |        TodoStateContext => 1 데이터 보관소
                              |
                          __TodoDispatchContext => 2차 데이터 보관소
                          |             |      |     |                            | 
                          |    TodoEditor  |    TodoList                   | 
                          |                    |                                  |  
                          |               TodoItem                            |  
                          ------------------------------------------------- 
        TodoStateContex ---Todo 데이터---> TodoList
        TodoDispatchContext ---onCreate( )데이터---> TodoEditor  
       TodoDispatchContext ---onUpdate( )데이터 & onDelete( )데이터---> TodoItem  