오늘부터 TS할거다
TS + React.js

JS 문법만 완벽하다면 하나도 어렵지 않을거다
FE 진입하려면 TS는 필수다 / 요즘 시대는 더욱 더

TS를 왜 배우는가?

https://2022.stateofjs.com/en-US

ts는 js기반이다

코테 준비할때 많이 참고 하는 사이트 / 유명한 사이트다
https://programmers.co.kr/pages/2023-dev-survey

잡코리아 검색
퍼블리셔도 요구하는 추세라 우위를 얻고싶으면 하나정도 준비해서가면 좋을거다


왜 typescript를 쓰냐?
모든 프로그래밍 언어는 거의 대부분 타입 시스템을 갖고있다

java를 포함한 C언어 등의 대부분의 언어들은 변수를 선언할 때, 사전에 변수안에 담겨야 할 값의 타입을 정의한다!
 => 물론 바꿀 수 있다
한번 정의된 타입은 계속 고정되어서 간다
사용자에게 어떤 숫자를 받는다
그 숫자가 로컬스토리지에 갔다가 다시 웹브러우저에 도착한다
해당 값을 찾아오는 순간 =>  자료의 형이 변환한다 (자료 형 변환)
 그때 number 함수를썼다 => Number( ) = Number( ) => 근본이 없는 언어다

JS => 단순히 웹브라우저에서 인터랙티브한 기능 구현
Node.js => JS 서버 구현 => 막대한 돈이 투입될 수 있는 프로젝트를 구현하는데 있어서 JS가 참여할 수 있다

TS는 2012년 C언어를 개발한 앤더슨이라는 사람이 개발했다
그러다 2016년에 재조명됐다
JS를 쓰다가 문제점들이 많이 나오자 TS가 JS의 문제점을 잡게됐다

TS는 JS의 타입을 사전 지정할 수 있도록 도와주는 슈퍼셋(*Super Set) 언어다
TS는 라이브러리도 아니고 프레임워크도 아니다

TS는 어디에서 구현할 수 있으며, 어떻게 사용하는가?
=> 웹 브라우저는 HTML, CSS, JS 밖에 이해를 못한다
그래서 scss를 사용할때도 컴파일러를 사용했다 => CSS로 변환해서 HTML이 가져갔다
TS가 JS로 사용되려면 컴파일링이 되어야한다 => 바로 Node에서 컴파일링이 실행된다
Node를 켜야지만 ts가 구현된다

Node = react사용할때 rpx(node package ex..) create-react-app
외부 라이어를 가져다 쓸때 npm... 를 썼었다
  => 모두 Node

node설치 되었는지 확인

node 시작
npm init 루트폴더에 node를 초기화 시킨다 라는 뜻

TS부터 하고 react를 했어야하는데 전기수 피드백 받고 바꿨다고 한단다


실무에서
npm init -y 나한테 물어보지말고 다 yes야

노드 초기화 완료

TS = JS안에 있는 명령어 /  변수 / 값 : 타입
Node : TS
node조차도 type을 정해줘야한다
npm i @types/node   node안에있는 모든 시스템의 타입을 정해라

node_modules가 태어났다 / 다 뒤에 ts가 붙는다
node에서 운영되는 모든것들은 ts에서 지정하겠다

TS 코드를 입력 => 웹

npm i typescript -g 타입스크립트를 js로 컴파일링하는 방법 / -g(global로 사용하겠다)
TS를 JS로 컴파일링 해주는 npm 앱이다

npm i typescript
한번 더 해야 된다 / history가 남게 해줘야 한다(jpackage.json에 history남게)

tsc -v  ts가 설치 되었는지 버전이 뭔지 찾아보는 명령어

tsc src/index.ts 컴파일링을 해라 / =>index.js가 생긴다 
  => src/index.ts 는 경로다 => src폴더에 index.ts파일

node src/index.js  node에서 실행시키는 명령어 index.js가 실행되게 / src폴더안에 있는 js파일을
                         실행시킬거야
     => src/index.ts 는 경로다 => src폴더에 index.ts파일
          => Hello TypeScript가 떠야 정상적으로 된거다

ts의 파일을 컴파일링함과 동시에 node로 실행까지 한번에 시켜줄 수 있는 앱이 필요하다!!!
==> ts-node   => tsc에서 ts  
 => npm i ts-node
 => npm i ts-node -g

ts-node src/index.ts  컴파일링과 동시에 실행
 Hello TypeScript가 뜬다

Compiling Option 할때 상황에 따라서 어떤 경우는 A방식으로 컴파일링 할 필요가 있고
어떤 경우는 B방식으로 컴파일링 할 필요가 있따

컴파일링 옵션창을 만들거다
tsc --init   초기값으로 init
 => tsconfig.json이 생겼다 => ts option에 들어갈 내용이다 
다 쓸필요 없다 필요한것만 기억해라
다 지워라

{
 "compilerOptions": {
    "target": "ES5"
  },
  "include": ["src"]
}

 => json이니까 객체 형태로 { }
경로설정   "include": ["src"]  => src폴더에 있는 파일

index.js 지우기

tsc 하면 알아서 컴파일링 된다

 "include": ["src"]는 큰 카테고리
세부적으로는 "compilerOptions": {} 안에 적어야한다
대부분은 "compilerOptions"안에서 움직인다

ts파일 =>  컴파일링
컴파일링이 완료된 JS 버전을 결정하는 옵션=> target이다

JS에서 forEach나 addEventlistener 쓸때 빼고는 화살표 함수를 썼었다
화살표 함수는 ES6문법 이후부터 나왔다
함수 구현을 funciton으로만 했었다

{
  "compilerOptions": {
    "target": "ESNext"
  },
  "include": ["src"]
}
하고 터미널에 tsc
"ESNext" => 최신 문법으로 해라 라는 명령어

타입스크립트 & 리액트 => .d

{
  "compilerOptions": {
    "target": "ESNext",
    "skipLibCheck": true
  },
  "include": ["src"]
}
로 바꾸기
skipLibCheck": true =>  환경 변수가 담겨져 있는 곳은 스킵해라
그리고 터미널에 tsc
에러가 안 뜬다

모듈
Node.js => JS 모듈 정식 표준 설정/생성 x

CommonJs
> import = require / export = exports.객체

ES의 모듈이 나왔다 => ESM

{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "skipLibCheck": true
  },
  "include": ["src"]
}
tsc



****CJS 모듈과 ESM 모듈의 차이점은?

* 또다른 옵션
tsconfig.json에
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "skipLibCheck": true
  },
  "include": ["src"]
}
tsc
"dist"폴더에 컴파일링 된 데이터가 갈거다


*
타입스크립트는
파일명이 달라도 변수명이 같으면 
전역요소는 재할당으로 선언된다

변수명을 바꾸는 방법
둘중 하나한테 export하는 방법
근본적인 방법 =>
tsconfig.json에 "moduleDetection": "force",
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    "skipLibCheck": true
  },
  "include": ["src"]
}

*기본적으로 알고가야할 옵션
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    "skipLibCheck": true
  },
  "include": ["src"]
}


ts-node src/index.ts  


모듈 이슈때매 CJS 모듈과 ESM 모듈때매
npm i tsx  설치해야한다 
npm i tsx -g  전역요소에서 설치해야한다


tsx src/index.ts
1이 나와야 정상이다 =>  변수값으로 1을 줬었었ㄴ으니까


CJS 모듈과 ESM 모듈을 호환해주는 옵션 => "esModuleInterop": true
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    "esModuleInterop": false,
    "skipLibCheck": true
  },
  "ts-node": {
    "esm": true
  },
  "include": ["src"]
}


TS와 React를 사용할때
모듈이 충돌날때 주는거
노드 기반에서 작동되게 하겠다 => "moduleResolution": "Node",
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    "esModuleInterop": true,
    "moduleResolution": "Node",
    "skipLibCheck": true
  },
  "ts-node": {
    "esm": true
  },
  "include": ["src"]
}



* "sourceMap": true,
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    "esModuleInterop": true,
    "moduleResolution": "Node",
    "sourceMap": true,
    "skipLibCheck": true
  },
  "ts-node": {
    "esm": true
  },
  "include": ["src"]
}
tsc

hello.js.map 보면 어떤 파일 기반으로 하는지 볼 수 있다



* "downlevelIteration": true,
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    "esModuleInterop": true,
    "moduleResolution": "Node",
    "sourceMap": true,
    "downlevelIteration": true,
    "skipLibCheck": true
  },
  "ts-node": {
    "esm": true
  },
  "include": ["src"]
}
tsc
반복문 쓰는데 에러나오면 "downlevelIteration": true 이거 사용하기



* "noImplicitAny": false,
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    "esModuleInterop": true,
    "moduleResolution": "Node",
    "sourceMap": true,
    "downlevelIteration": true,
    "skipLibCheck": true
  },
  "ts-node": {
    "esm": true
  },
  "include": ["src"]
}
tsc



* "allowJs": true,
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "outDir": "dist",
    "strict": true,
    "moduleDetection": "force",
    "esModuleInterop": true,
    "moduleResolution": "Node",
    "sourceMap": true,
    "downlevelIteration": true,
    "skipLibCheck": true
  },
  "ts-node": {
    "esm": true
  },
  "include": ["src"]
}
ts가 js를 끌고 오고 싶을때



====> 이정도의 옵션까지는 알고 있어야 한다


{
  "name": "240429",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "dev": "tsx src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/node": "^20.12.7",
    "ts-node": "^10.9.2",
    "tsx": "^4.7.3",
    "typescript": "^5.4.5"
  }
}
"dev": "tsx src/index.ts", 단축키다


{
  "name": "240429",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "dev": "tsx src/index.ts",
    "build": "tsc && node dist",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/node": "^20.12.7",
    "ts-node": "^10.9.2",
    "tsx": "^4.7.3",
    "typescript": "^5.4.5"
  }
}
"build": "tsc && node dist", 단축키다
-----------------------------------------------

1. TS를 사용해야하는 이유
2. TS를 세팅하는 방법
3. TS CompilerOptions 세팅하는 방법

-----------------------------------------------

1. TS 주석
 - JS 타입 종류
1) 원시타입 : number, string, boolean, null, undefined
2) 참조타입 : object객체, array배열, function함수


2. TS 추론
 - 굳이 꼭 주석을 달지 않아도 된다
(*하지만, 특별한 케이스에는 달아야한다)


3. TS 치트키 (*any타입)


4. TS
 - JS와 비교해봤을때 => undefined(값이 정의 되지 않았을때) / null(값이 잘못됐을때): value
 - TS에서도 타입이다


5. TS타입의 분류를 나눈다 - Super Type과 Sub Type로 나뉜다
 - Super Type : 이걸로 갈 수록 받을 수 있는 값이 많아 진다 (상위개념)
 - Sub Type : 이걸로 갈 수록 받을 수 있는 값이 적어 진다 (하위개념)
any는 Super Type이고 null, number, boolean, string, object등등은 SubType이다


6. TS에서 객체 타입 정의
let o: object = {};
실무에서는 objec 타입을 거의 안 쓴다!!! => 이유: 있으나 마나해서
 - object => 객체계의 any다!!!!(객체계의 치트키다!!)
 - interface => 객체 안에 들어가 있는 각각의 key & value 타입 정의한다
    interface 진짜 많이 쓴다
 - optional property => 선택속성 (*객체안에 있어도 되고, 없어도 되는 값에 대한 타입을 정의하고자 할 때)
   사용자 선택으로 값이 있을수 있고 없을 수도 있는 상황, 경우에 optional property준다
 - 익명 interface => 이름을 부여하지 않은 interface가 존재한다


7. Class 타입 정의하기
Class 주는 이유 => 동일한 혹은 유사한 형태의 객체가 많이 필요한 상황에서 
매변 해당 객체를 신규로 생성해야하는 그 불편함을 해소하기 위해서 class 사용한다
붕어빵틀 / 붕어빵 / instance 개념 /
 - new Class( )


8. interface 응용
 - interface: 객체의 세부 타입 정의 할때 사용한다
 - class 선언 할 때 참고 활용 할 수 있다
 - class가 interface를 참고해서 객체를 구현할 때에는 implements 명령어를 쓴다
   (*implement : 실행하다)
    => *반드시 implement를 하기로 한 인터페이스 객체를 구현해야한다!


9. 추상클래스
 - 추상화 
 - 추상 <-> 명쾌하지 않음
 - 어떤 사물이나 개념에서 공통점을 찾아서 추출한 형이상항적인 개념

 A라는 객체
  : 강아지 정보
  : 종류 : 동물
  : 다리 : 4개
  : 귀 : 2개
  : 사료 : 강아지밥
 B라는 객체가 있다
  : 고양이 정보
  : 종류 : 동물
  : 다리 : 4개
  : 귀 : 2개
  : 사료 : 고양이밥
 ====> A와 B의 공통점이 있다

객체를 생성하는데 있어서 객체의 세부적인 값들이 완전히 똑같아야할 수도 있지만,
특정요소 몇가지만 다르고, 나머지 70~80%는 거의 동일한 구성형태를 띄고 있는 
객체를 만들어야하는 상황이 나올 수 있다

10~20%의 차이점때문에 매번 새롭게 class를 생성해야하는가?

===> No! 추상클래스를 활용하면된다
