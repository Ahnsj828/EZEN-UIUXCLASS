1. Java가 아니라 Javascript (ES기업이)
  Java - 데이터베이스 구출
  Javascript - UI를 구현하기 위한 언어
  
2. JS 할거다
   오후에 Figma + Box-model 구조를 잡고 
    + Html & CSS+ Js (이번주나 다음주까지)

3. 퍼블리셔 실무 실전예제를 많이 할거다

4. TS(타입스크립트) / React / Node.js(상황에따라서)

-------------------------------------------------------

< JS Process > JS => 싱글스레드로 작동하는 객체지향 프로그래밍 언어이다
JS 최대약점 -> 싱글스레드다 / 싱글 -> 1 , 스레드-> 길  => 1차선 통행
위에서 작성한 순서대로 읽는걸 싱글스레드라고한다
동시성이 안된다X / 비동기 처리가 안된다X
 로딩 스피너가 없으면 JS는 꽝이다

<-> 멀티스레드 :  복수차선 / 동시로 가능하다 / 대표적으로 파이썬이 있다

1. 변수

2. 자료형(태/식)

3. 자료형 변환 = 형변환 (자료형에 대한 변환)
  - 문자 => 숫자로 변환 - 쌤은 Number( )를 쓰신다(가장 강력한상위개념이라)
  - 숫자 => 문자로 변환 - 쌤은 String( )를 쓰신다(가장 강력한상위개념이라)
     Number, String 이 다른 개념들을 포괄해서
  - 문자 & 숫자 => 논리 Boolean ( )

4. 연산자
 - 산술연산자 : + - / *
 - 연결연산자
 - 할당연산자
 - 비교연산자
 - 논리연산자
(***삼항조건연산자) 항이 세개이인 조건인 연산자 - 너무 중요하다!!!

5. 제어문
 - 조건문
  > if문 - 만약에 ~라면 이거해줘
  > if...else문 (*else if문) - 이거아니면 이거?
  > switch문 -이중에서 골라
  
 - 반복문
  > for문 - ~하는 동안에
  > forEach문
  > for..in문 => 객체 전용
  > for...of문 => 배열전용
  > while문
  > do...while문
 (*break문 & continue문)

------------------------------------------------------------------------

6. 함수 => 자바스크립트의 꽃 / 핵심요소다
 => 어떤 여러 "기능" 및 "명령"들을 하나로 묶어놓은 집합체 or 그룹
     ex. html에서 구현가능한 동영상을 찾아와라(명령)
         해당 동영상을 찾아와서 내가 원하는 사이즈로 화면에 구현시켜라(명령)
 => 굳이 개별 기능, 명령들을 따로따로 독립적으로 실행시키지 않아도 구현 가능!
 => 함수는 어떻게 생겼는가?
 - 클래스 / 익명 / 화살표
 - 매개변수 & 인수(*인자값)
 - return (*함수 결과값 반환)
 - 스코프 (*블록 / 지역 / 전역)
 - var 쓰지마라 / 지역스코프 변수 / const (*권장)
 - 즉시실행함수
 - 변수선언 키워드 입력 => 전역변수
 - hoisting (*클래스함수 VS 익명함수 & 화살표)
 - JS를 1급 시민이라고 한다
 - 전개연산자 구문
 - 나머지 매개변수
 - 시간관련 내장함수
(* setInterval / setTimeout)
 - 재귀함수 

// 자바스크립트 문법을 들으면 이해가 된다 
   but, 코드를 치거나 구현하려고 하면 막막하다고 한다
    => 지극히 정상이다
// 문법을 배우는것과 실행하는것은 다르다
// 집에가서 그날그날 배운것을 1번이상 직접 쳐봐라
   => 이해 안되면 mdn 확인해라!

================================================


prompt();
// prompt함수
// alert();
alert함수
document.write();
// write함수 document는 함수가 아니다 객체다

*함수의 생김새
 단어(=키워드) () => 함수

함수가 작동하려면 무엇이 필요할까?
1. 함수를 구현 해야한다 = 제작
2. 함수를 호출해야한다 = 실행

함수를 구현하려면 어떻게 해야할까?
함수를 구현하는 방법은 총 3가지가 있다
(정답은 없다 상황에 맞춰서 효율적인 방법을 써라)
  1. 클래스 함수를 구현하는 방법
  2. 익명의 함수를 구현하는 방법 (함수의 이름을 정의하지 않고 구현하는거)
  3. 화살표 함수를 구현하는 방법 (가장 최신문법 but, 늘 정답은 아니다)

<초보레벨>
1부터 5까지 더하라
let num = 0;
nut += 1;
nut += 2;
nut += 3;
nut += 4;
nut += 5;
이러다 더 많아지면 힘들어진다

<중급 레벨단계> 반복문 사용
반복문을 사용하면 된다
let sum = 0
for(let i = 1; i <= 5; i++) {
  sum += i;
}
만약 숫자를 1~5 이 아니라 1~100까지 더해야된다면 
매상황에 맞춰서 코드를 신규로 맞춰야된다 => 비효율적이다
let sum = 0
for(let i = 1; i <= 100; i++) {
  sum += i;
}

< 고급 레벨단계 > 함수 활용 - 재활용이 가능한 코드 업그레이드
function calSum() {
  let sum = 0;
  for (let i = 1; i <= 5; i++) {
    sum += i;
  }
  cosole.log("1부터 5까지 더하면 ${sum} 입니다");
}
 => 클래스 함수를 구현했다 / 함수로 감싸 안았다
 calcSum()
 => 함수를 호출했다
prompt(), alert() => 내장함수라 구현하지 않았다  호출만했다
calSum함수명
() 매개변수의 자리
매개변수 = 매개체


매번 숫자를 번거롭게 바꾸지 않고 밑에처럼 하면된다
function calSum(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  cosole.log("1부터 ${n}까지 더하면 ${sum} 입니다");
}
calcSum(20);
20 인수값 인자값 
인수값/인자값만 바꾸면된다



  < 클래스 함수 >
 const userNum01 = Number(prompt("첫번째 숫자를 입력하세요!"));
 const userNum02 = Number(prompt("두번째 숫자를 입력하세요!"));
 
 function sum(a, b) {
   const result = a + b;
   alert(`두 수의 합은 ${result} 입니다`);
 }
 sum(userNum01, userNum02);


  < 익명 함수 > 익명의 함수를 구현하는 방법 (함수의 이름을 정의하지 않고 구현하는거)
const userNum01 = Number(prompt("첫번째 숫자를 입력하세요!"));
const userNum02 = Number(prompt("두번째 숫자를 입력하세요!"));
const sum = function (a, b) {
   const result = a + b;
   alert(`두 수의 합은 ${result} 입니다`);
 }
 sum(userNum01, userNum02);
 함수를 변수로 할당할수 있어야 익명함수를 쓸수 있다


  < 화살표 함수 >
const userNum01 = Number(prompt("첫번째 숫자를 입력하세요!"));
const userNum02 = Number(prompt("두번째 숫자를 입력하세요!"));
const sum = (a, b) => {
  const result = a + b;
  alert(`두 수의 합은 ${result} 입니다`);
}
sum(userNum01, userNum02);

* 인수 = 인자값 


 < retrun문 >  밖으로 꺼내고 싶을때


기본매개 변수



< scope 개념이 너무너무 중요하다! >
* local scope = 지역스코프 = 지역방송 = 해당 변수를 특정영역 안에서만 사용할 수 있도록 하는 변수값
* block scope = 블록스코프 = 해당 변수가 선언된 블록 안에서만 유효한 변수값
* global scope = 전역스코프 = 해당 변수를 현 자바스크립트 파일 내 어디에서든 사용이 가능한 변수값



<< JS 권장사항!! >>
1. var보다는 let, const 키워드로 변수를 선언해라!
function addSum(n) {
  var sum = 0;
  for (var i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}
var num = 3;
console.log(`1부터 ${num}까지 더하면 ${addSum(num)}`);

2. 가급적이면, 전역 스코프의 변수선언은 피해라! (하지말라는건 아니다)
(지역 혹은 블록으로)

3. 그래서 var, let 보다는 const에 적응해라!
    const위주로 쓰고 재할당이 필요한 순간에서는 let을써라



<< 즉시 실행 함수!! >> - 한방에 붙여서쓰는거 / 고차함수 쓸 때 많이 쓴다!!

Hoisting 기법
무언가를 끌어올리다!
class함수는 Hoisting이 가능 / 화살표 함수와 익명 함수는 Hoisting이 불가능하다

* 화살표 함수에서는 매개변수가 존재하지 않는 경우에는 실행문을 보호하는 중괄호 & 값을 반환시켜주는 return문을 생략해도 문제없이 작동 가능하다!!

* 화살표 함수 탄생 이유 : (ES6문법)
  1. 반복적으로 사용되는 function & 함수명을 생략!
  2. JS 근본없는 구현 & 호풀부의 순서를 명확하게 정의!
  3. 함수의 실행문에서 굳이 중괄호 & return문 사용하지 않아도 구현할 수 있도록 해주기 위한 목적! 

* 변수 선언 시, let과 const와 var 사용하지 않으면 무조건 전역 변수화!!

// <<콜백함수>> - 함수 안에 또다른 함수를 호출할 때 
html에서는 태그라고 부르고
js 에서는 노드라고 부른다


* Java / python / C 등등 기타 프로그래밍 언어 함수!
* JS 함수 => 1급 시민이라고 부른다 => first-class citizen
* 모든 프로그래밍 언어에서 1급시민이 되려면 다음과 같은 조건에 부합해야 한다
  1. 함수를 변수에 값으로 할당할 수 있어야 한다!
  2. 함수가 또다른 함수의 매개변수 혹은 인자값으로 사용될 수 있어야 한다!
  3. 함수가 또다른 함수의 return안에 반환값으로 들어올 수 있어야한다! (자바스크립트가 고차함수가 될수 있는 이유)
      => 이걸 다 깨우치면 고차함수를 할 수 있다

// << window 운영체제안에 => 내장함수!! 사용할거다 >>
// JS => 싱글스레드로 작동하는 객체지향 프로그래밍 언어이다
// JS 최대약점 -> 싱글스레드다 / 싱글 -> 1 , 스레드-> 길  => 1차선 통행
// 위에서 작성한 순서대로 읽는걸 싱글스레드라고한다
// 동시성이 안된다X / 비동기 처리가 안된다X
// 로딩 스피너가 없으면 JS는 꽝이다

// <-> 멀티스레드 :  복수차선 / 동시로 가능하다 / 대표적으로 파이썬이 있다



// 비동기처리 함수
// 1. setInterval() : 일정 시간마다 반복해서 무언가를 처리하는 함수!
const greeting = () => {
  console.log("안녕하세요!");
};
setInterval(greeting, 2000);
// setInterval(실행시키고자하는 함수, 2초동안)
// 1000밀리초 = 1초
// 여기에서 greeting은 콜백함수다
setInterval(() => {
  console.log("안녕하세요!")
}, 2000);

clearInterval(): 특정 조건에 따라서 반복실행 함수를 멈추게 하는 함수
setTimeout() : 특정 시간이 경과한 이후에 작동하게 만드는 함수!!
                     => heap / callstack / Que